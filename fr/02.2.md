# 2.2 Fondations de Go

Dans cette section, nous allons voir comment définir des constantes, des variables utilisant les types élémentaires, et acquérir quelque compétences en programmation Go.

## Définition de variables

Il y a plusieurs syntaxes pouvant être utilisées pour définir des variables en Go.

L'utilisation du mot clé `var` est la méthode basique pour définir des variables. Notez que Go place le type de la variable `aprés` son nom.

	// Définition d'une variable ayant pour nom "variableName" et pour type "type"
	var variableName type

Définition de plusieurs variables.

	// Définition de trois variables de type "type"
	var vname1, vname2, vname3 type

Définition d'une variable ayant une valeur initiale.

	// Définition d'une variable s'appelant "variableName", de type "type", et ayant pour valeur "value"
	var variableName type = value

Définition de plusieurs variable ayant des valeurs initiales.

	/*
	Définition de 3 variables de type "type", en initialisant leur valeurs avec
    v1 pour vname1, v2 pour vname2, et v3 pour vname3
	*/
	var vname1, vname2, vname3 type = v1, v2, v3

Vous trouvez qu'il est fastidieux de définir les variables en utilisant la méthode ci-dessus ? Ne vous inquiétez pas, l'équipe de Go pense également que c'est un problème. Par conséquent, si vous voulez définir des variables ayant une valeur initiale, vous pouvez simplement omettre de déclarer un type, comme suit :

	/*
	Définition de 3 variables sans type "type", et initialisation de leur valeurs avec
	v1 pour vname1, v2 pour vname2, et v3 pour vname3
	*/
	var vname1, vname2, vname3 = v1, v2, v3

Enfin, je sais que ce n'est toujours pas suffisamment simple à votre goût. Voyont comment y remédier.

	/*
	Définition de 3 variables sans type "type", et sans mot-clé "var", tout en les initialisant avec
	les valeurs v1 pour vname1, v2 pour vname2, et v3 pour vname3
	*/
	vname1, vname2, vname3 := v1, v2, v3

C'est maintenant beaucoup mieux. L'utilisation de `:=` pour remplacer `var` et `type` est appelée une déclaration brève. Cette forme a cependant une limitation : elle ne peut être utilisée qu'à l'intérieur d'une fonction. Vous aurez des erreurs de compilation si vous essayez de l'utiliser en dehors du corps d'une fonction. Nous utiliserons généralement `var` pour définir les variables globales et nous pouvons utiliser cette déclaration brève dans `var()`.

`_` (blank) est une variable spéciale. N'importe quelle valeur qui lui est assignée sera ignorée. Par exemple, nous pouvons assigner `35` à `b`, et ignorer le `34`. (***Cet exemple ne sert qu'à illustrer le fonctionneent. Il semble inutile, mais on utilise souvent ce symbole quand une fonction retourne plusieurs valeurs)

	_, b := 34, 35

Si vous n'utilisez pas les variables définies dans votre programme, le compilateur vous remontera des erreurs. Essayez de compiler le code suivant et voyez ce qui se passe.

	package main

	func main() {
	    var i int
	}

## Constantes

Les constantes sont des valeurs qui sont déterminées au moment de la compilation, et dont il n'est pas possible de changer la valeur pendant l’exécution. En Go, vous pouvez utiliser des constante de type numérique, booléen ou chaîne de caractères.

Les constantes se définissent comme suit.

	const constantName = value
	// vous pouvez assigner des types aux constantes si nécessaire
	const Pi float32 = 3.1415926

D'autres exemples :

	const Pi = 3.1415926
	const i = 10000
	const MaxThread = 10
	const prefix = "astaxie_"

## Types de base

### Booléen

En go, on utilise `bool` pour définir une variable comme booléenne, et sa valeur ne peut être que `true` ou `false`, cette dernière étant la valeur par défaut. ( ***Il est impossible de convertir le type d'une variable de nombre à booléen!*** )

In Go, we use `bool` to define a variable as boolean type, the value can only be `true` or `false`, and `false` will be the default value. ( ***You cannot convert variables' type between number and boolean!*** )

	// Exemple
	var isActive bool  // Variable globale
	var enabled, disabled = true, false  // Type implicitement déclaré
	func test() {
    	var available bool  // variable locale
    	valid := false      // déclaration brève
    	available = true    // assignation d'une valeur à la variable
	}

### Types numériques

Les nombres entiers (Integer) peuvent être signés ou non-signés. Go propose les types `int` et `uint`, de même longueur, dont la longueur spécifique varie selon votre système: 32-bits sur les systèmes 32-bits, et 64-bits sur les systèmes 64-bits. Go a également des type de longueur spécifiques, comme `rune, int8`, `int16`, `int32`, `int64`, `byte`, `uint8`, `uint16`, `uint32`, `uint64`. Notez que `rune` est un alias pour `int32` et `byte un alias pour `uint8`.

Il est important de savoir que vous ne pouvez pas assigner la valeur d'une variable d'un de ces type à une autre d'un autre type, cela provoquerait des erreurs de compilation.

	var a int8

	var b int32

	c := a + b

Malgrés le fait qu'int32 soit codé sur un plus grand nombre d'octets que int8, et est du même type qu'int, vous ne pouvez pas interchanger leurs valeurs. ( ***c sera implicitement déclaré de type `int` dans l'exemple ci-dessus)

Les nombres décimaux peuvent être déclarés avec les types `float32` et `float64`; il n'y a pas de type appelé `float`. `float64` est utilisé par défaut dans le cas d'une déclaration brève.

Go supporte également les nombres complexes ! `complex128` (avec une partie réelle sur 64-bits, et une partie imaginaire sur 64-bits) est le type par défaut. Si vous avez besoin d'un type plus petit, vous pouvez utilise `complex64` (avec une partie réelle et une partie imaginaire sur 32-bits chacunes). Ils sont écrits sous la forme `RE+IMi`, où `RE` est la partie réelle, et `IM` est la partie imaginaire, le `i` final étant le nombre imaginaire. Voici un exemple de nombre complexe.

	var c complex64 = 5+5i
	//sortie: (5+5i)
	fmt.Printf("Value is: %v", c)

### Chaines de caractères

Nous avons vu plus haut que Go utilise le jeux de caractères UTF-8. Les chaines de caractères sont représentées par des guillemets `""` ou des backticks ``` `` ```.

	// Exemple de code
	var frenchHello string  // Forme basique
	var emptyString string = ""  // Chaine vide
	func test() {
    	no, yes, maybe := "no", "yes", "maybe"  // Déclaration brève
    	japaneseHello := "Ohaiou"
    	frenchHello = "Bonjour"  // assignation d'une valeur
	}

Il n'est pas possible de modifier les caractères de la chaine par leur index. Vous obtiendrez des erreurs en compilant le code suivant :

	var s string = "hello"
	s[0] = 'c'

Mais alors, comment faire pour changer uniquement un caractère dans une chaine ? Essayez le code suivant :

	s := "hello"
	c := []byte(s)  // convertion d'un string en []byte
	c[0] = 'c'
	s2 := string(c)  // re-convertion en string
	fmt.Printf("%s\n", s2)

Pour concaténer 2 strings, utilisez l'opérateur `+` :

	s := "hello,"
	m := " world"
	a := s + m
	fmt.Printf("%s\n", a)

mais aussi :

	s := "hello"
	s = "c" + s[1:] // vous ne pouvez pas modifier la valeur d'un caractère via son index, mais vous pouvez en récupérer la valeur
	fmt.Printf("%s\n", s)

Comment faire pour créer une chaine de caractères s'étendant sur plusieur lignes ?
What if I want to have a multiple-line string?

	m := `hello
    world`

`` ` n'échapera aucun des caractères de la chaine.

### Types d'erreurs

Go propose un type `error` ayant pour but de traiter les messages d'erreur. Il y a également un package appelé `errors` permettant de gérer les erreurs.

	err := errors.New("emit macho dwarf: elf header corrupted")
	if err != nil {
    	fmt.Print(err)
	}

### Structure de données sous-jacente

L'image ci-dessous provient d'un article du [blog de Russ Cox](http://research.swtch.com/) sur la [Structures de données de Go](http://research.swtch.com/godata). Comme vous pouvez le voir, Go utilise des blocs mémoire pour stocker ses données.
The following picture comes from an article about [Go data structure](http://research.swtch.com/godata) in [Russ Cox Blog](http://research.swtch.com/). As you can see, Go utilizes blocks of memory to store data.

![](images/2.2.basic.png?raw=true)

Figure 2.1 Structure interne des données de Go

## Some skills

### Définition par groupe

Si vous voulez définir plusieur constantes, variables, ou importer plusieur packages, vous pouvez utilise la forme par groupe.

Forme basique :

	import "fmt"
	import "os"

	const i = 100
	const pi = 3.1415
	const prefix = "Go_"

	var i int
	var pi float32
	var prefix string

Forme par groupe :

	import(
    	"fmt"
    	"os"
	)

	const(
    	i = 100
    	pi = 3.1415
    	prefix = "Go_"
	)

	var(
    	i int
    	pi float32
    	prefix string
	)

A moins que la valeur de la constante soit `iota`, la première valeur de constante dans le groupe `const()` sera `0`. Si les constantes suivantes n'ont pas de valeur explicitement assignées, leur valeurs sera la même que la précédente. Si la valeur de la constante précédente est `iota`, les valeurs des constantes suivantes auxquelles ne sont assignées aucune valeurs seront également `iota`.

### Enumérations avec iota

Go possède un mot-clé, `iota`, permettant de faire des énumérations commençant par 0, et incrémentées de 1.

	const(
    	x = iota  // x == 0
    	y = iota  // y == 1
    	z = iota  // z == 2
    	w  // Si il n'y a pas d'expretion aprés le nom de la constante, elle utilisera la dernière expression, donc on déclare ici implicitement que w = iota. Par conséquent, w == 3, et y et z peuvent tous les également deux omettre "= iota"
	)

	const v = iota // quand iota rencontre le mot clé `const`, il est réinitialisé à 0, donc v = 0

	const (
	  e, f, g = iota, iota, iota // e=0,f=0,g=0 : la valeur de iota reste identique sur une même ligne
	)

### Quelque règles

La raison pour laquelle Go est concis est qu'il a des comportements par défaut.

- Toute variable commençant par une lettre majuscule sera exportée, et restera privée dans le cas contraire.
- La même règle s'applique aux fonctions et aux constantes; il n'y a pas de mot-clé `public` ou `private` en Go.

## array, slice, map

### array

`array` permet de définir un tableau, comme suit :

	var arr [n]type

dans `[n]type`, `n` est la taille du tableau, `type` est le type de ses éléments. Comme dans les autres languages, nous utiliserons `[]` pour accéder aux éléments d'un tableau.

	var arr [10]int  // tableau de 10 entiers
	arr[0] = 42      // l'index des tableaux commence à 0
	arr[1] = 13      // assignation d'une valeur à un élément
	fmt.Printf("The first element is %d\n", arr[0])  // récupération de la valeur d'un élément, 42 dans ce cas
	fmt.Printf("The last element is %d\n", arr[9]) // retourne la valeur par défaut du 10ème élément du tableau, 0 dans ce cas

La longueur faisant partie du type du tableau, `[3]int` et `[4]int` sont des types différents. On ne peut par conséquent pas changer la longueur d'un tableau. Quand vous utilisez des tableaux comme arguments, les fonctions les recoivent par copie et non par référence. Si vous devez passer la référence d'un tableau à une fonction, vous préfèrerez utiliser le type `slice` (qu'on abordera un peu plus loin).

Il est possible d'utiliser `:=` quand vous définissez des tableaux :

	a := [3]int{1, 2, 3} // tableau d'int ayant 3 éléments

	b := [10]int{1, 2, 3} // tableau d'int de 10 éléments, dont les 3 premiers ont une valeur, et dont les autres éléments ont une valeur par défaut de 0

	c := [...]int{4, 5, 6} // Si vous remplacez la longueur par `...`, Go calculera la longueur pour vous

Il est possible de créer des tableaux à plusieurs dimensions :

	// définition d'un tableau bi-dimensionnel avec 2 éléments, chaque élément ayant 4 éléments
	doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}

	// la déclaration peut être écrite de manière plus concise
	easyArray := [2][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}}

Structure de donnée sous-jacente des tableaux :

![](images/2.2.array.png?raw=true)

Figure 2.2 Multidimensional array mapping relationship

### slice

Dans beaucoup de situations, le type `array` n'est pas un bon choix - par exemple quand on ne sait pas à l'avance la taille du tableau. Par conséquent, il nous faut un "tableau dynamique". En Go, il est appelé `slice`.

`slice` n'est pas vraiment un "tableau dynamique". C'est un type de référence. `slice` pointe vers un tableau dont la déclaration est similaire à `array`, mais ne nécéssite pas de taille.

	// identique à la déclaration d'un tableau, mais sans préciser la longueur
	var fslice []int

On peut ensuite définir un `slice`, et initialiser son contenu :

	slice := []byte {'a', 'b', 'c', 'd'}

`slice` peut être utilisé pour reféfinir d'autre `slice`, ou des `array`. `slice` utilise `array[i:j]` pour faire des tranches, où `i` est l'index de départ, et `j` l'index de fin. Cela dit, `array[j]` ne pourra pas être redéfini en `slice` car la longueur de la tranche est `j-i`.
`slice` can redefine existing slices or arrays. `slice` uses `array[i:j]` to slice, where `i` is the start index and `j` is end index, but notice that `array[j]` will not be sliced since the length of the slice is `j-i`.

	// définition d'un tableau de 10 bytes
	var ar = [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}

	// déclaration de 2 slices de type []byte
	var a, b []byte

	// 'a' pointe vers les éléments 3 à 5 du tableau ar
	a = ar[2:5]
	// maintenant 'a' a pour éléments ar[2],ar[3] et ar[4]

	// 'b' est un autre slice du tableau ar
	b = ar[3:5]
	// 'b' a maintenant les éléments ar[3] et ar[4]

Remarquez les différences entre `slice` et `array` quand vous les définissez. On peut utiliser `[...]` pour laisse Go calculer la taille d'un tableau, mais `[]` ne permet que de définir des `slice`.

Leur structure de données sous-jacente :

![](images/2.2.slice.png?raw=true)

Figure 2.3 Correspondence between slice and array

`slice` a des opérations pratiques :
- le premier index d'un `slice` est 0, `ar[:n]` équivaut à `ar[0:n]`
- le second index, si omis, sera la taille du `slice` : `ar[n:]` équivaut à `ar[n:len(ar)]`
- vous pouvez utiliser `ar[:]` pour récupérer un tableau dans son intégralité

D'autres exemples d'utilisation de `slice`

	// définition d'un tableau
	var array = [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}
	// définition de deux slices
	var aSlice, bSlice []byte

	// opération pratiques
	aSlice = array[:3] // équivaut à aSlice = array[0:3] aSlice a les éléments a,b,c
	aSlice = array[5:] // équivaut à aSlice = array[5:10] aSlice a les éléments f,g,h,i,j
	aSlice = array[:]  // équivaut à aSlice = array[0:10] aSlice a tous les éléments

	// slice à slice
	aSlice = array[3:7]  // aSlice a les éléments d,e,f,g，len=4，cap=7
	bSlice = aSlice[1:3] // bSlice contient aSlice[1], aSlice[2], et a donc les éléments e,f
	bSlice = aSlice[:3]  // bSlice contient aSlice[0], aSlice[1], aSlice[2], a donc les éléments d,e,f
	bSlice = aSlice[0:5] // maintenant bSlice contient d,e,f,g,h
	bSlice = aSlice[:]   // bSlice a les mêmes éléments que aSlice, soit d,e,f,g

`slice` is a reference type, so any changes will affect other variables pointing to the same slice or array. For instance, in the case of `aSlice` and `bSlice` above, if you change the value of an element in `aSlice`, `bSlice` will be changed as well.

`slice` is like a struct by definition and it contains 3 parts.

- A pointer that points to where `slice` starts.
- The length of `slice`.
- Capacity, the length from start index to end index of `slice`.

		Array_a := [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}
		Slice_a := Array_a[2:5]

The underlying data structure of the code above as follows.

![](images/2.2.slice2.png?raw=true)

Figure 2.4 Array information of slice

There are some built-in functions for slice.

- `len` gets the length of `slice`.
- `cap` gets the maximum length of `slice`
- `append` appends one or more elements to `slice`, and returns `slice` .
- `copy` copies elements from one slice to the other, and returns the number of elements that were copied.

Attention: `append` will change the array that `slice` points to, and affect other slices that point to the same array. Also, if there is not enough length for the slice (`(cap-len) == 0`), `append` returns a new array for this slice. When this happens, other slices pointing to the old array will not be affected.

### map

`map` behaves like a dictionary in Python. Use the form `map[keyType]valueType` to define it.

Let's see some code. The 'set' and 'get' values in `map` are similar to `slice`, however the index in `slice` can only be of type 'int' while `map` can use much more than that: for example `int`, `string`, or whatever you want. Also, they are all able to use `==` and `!=` to compare values.

	// use string as the key type, int as the value type, and `make` initialize it.
	var numbers map[string] int
	// another way to define map
	numbers := make(map[string]int)
	numbers["one"] = 1  // assign value by key
	numbers["ten"] = 10
	numbers["three"] = 3

	fmt.Println("The third number is: ", numbers["three"]) // get values
	// It prints: The third number is: 3

Some notes when you use map.

- `map` is disorderly. Everytime you print `map` you will get different results. It's impossible to get values by `index` -you have to use `key`.
- `map` doesn't have a fixed length. It's a reference type just like `slice`.
- `len` works for `map` also. It returns how many `key`s that map has.
- It's quite easy to change the value through `map`. Simply use `numbers["one"]=11` to change the value of `key` one to `11`.

You can use form `key:val` to initialize map's values, and `map` has built-in methods to check if the `key` exists.

Use `delete` to delete an element in `map`.

	// Initialize a map
	rating := map[string]float32 {"C":5, "Go":4.5, "Python":4.5, "C++":2 }
	// map has two return values. For the second return value, if the key doesn't exist，'ok' returns false. It returns true otherwise.
	csharpRating, ok := rating["C#"]
	if ok {
    	fmt.Println("C# is in the map and its rating is ", csharpRating)
	} else {
    fmt.Println("We have no rating associated with C# in the map")
	}

	delete(rating, "C")  // delete element with key "c"

As I said above, `map` is a reference type. If two `map`s point to same underlying data, any change will affect both of them.

	m := make(map[string]string)
	m["Hello"] = "Bonjour"
	m1 := m
	m1["Hello"] = "Salut"  // now the value of m["hello"] is Salut

### make, new

`make` does memory allocation for built-in models, such as `map`, `slice`, and `channel`, while `new` is for types' memory allocation.

`new(T)` allocates zero-value to type `T`'s memory, returns its memory address, which is the value of type `*T`. By Go's definition, it returns a pointer which points to type `T`'s zero-value.

`new` returns pointers.

The built-in function `make(T, args)` has different purposes than `new(T)`. `make` can be used for `slice`, `map`, and `channel`, and returns a type `T` with an initial value. The reason for doing this is because the underlying data of these three types must be initialized before they point to them. For example, a `slice` contains a pointer that points to the underlying `array`, length and capacity. Before these data are initialized, `slice` is `nil`, so for `slice`, `map` and `channel`, `make` initializes their underlying data and assigns some suitable values.

`make` returns non-zero values.

The following picture shows how `new` and `make` are different.

![](images/2.2.makenew.png?raw=true)

Figure 2.5 Underlying memory allocation of make and new

Zero-value does not mean empty value. It's the value that variables default to in most cases. Here is a list of some zero-values.

	int     0
	int8    0
	int32   0
	int64   0
	uint    0x0
	rune    0 // the actual type of rune is int32
	byte    0x0 // the actual type of byte is uint8
	float32 0 // length is 4 byte
	float64 0 //length is 8 byte
	bool    false
	string  ""

## Links

- [Directory](preface.md)
- Previous section: ["Hello, Go"](02.1.md)
- Next section: [Control statements and functions](02.3.md)
